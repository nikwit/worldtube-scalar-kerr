diff --git a/src/Evolution/DiscontinuousGalerkin/DgElementArray.hpp b/src/Evolution/DiscontinuousGalerkin/DgElementArray.hpp
index 5631cd867..356bc2716 100644
--- a/src/Evolution/DiscontinuousGalerkin/DgElementArray.hpp
+++ b/src/Evolution/DiscontinuousGalerkin/DgElementArray.hpp
@@ -114,7 +114,7 @@ void DgElementArray<Metavariables, PhaseDepActionList>::allocate_array(
   const size_t num_of_procs_to_use = number_of_procs - procs_to_ignore.size();
 
   const auto& blocks = domain.blocks();
-
+const auto& worldtube = domain.excision_spheres().at("ExcisionSphereA");
   Parallel::create_elements_using_distribution(
       [&dg_element_array, &global_cache, &initialization_items](
           const ElementId<volume_dim>& element_id, const size_t target_proc,
@@ -122,7 +122,7 @@ void DgElementArray<Metavariables, PhaseDepActionList>::allocate_array(
         dg_element_array(element_id)
             .insert(global_cache, initialization_items, target_proc);
       },
-      element_weight, blocks, initial_extents, initial_refinement_levels,
+      element_weight, blocks, worldtube, initial_extents, initial_refinement_levels,
       i1_basis, i1_quadrature,
 
       procs_to_ignore, number_of_procs, number_of_nodes, num_of_procs_to_use,
diff --git a/src/Parallel/ArrayCollection/CreateElementsUsingDistribution.hpp b/src/Parallel/ArrayCollection/CreateElementsUsingDistribution.hpp
index ef0aad0ab..66c5cea14 100644
--- a/src/Parallel/ArrayCollection/CreateElementsUsingDistribution.hpp
+++ b/src/Parallel/ArrayCollection/CreateElementsUsingDistribution.hpp
@@ -13,6 +13,7 @@
 
 #include "Domain/Block.hpp"
 #include "Domain/ElementDistribution.hpp"
+#include "Domain/ExcisionSphere.hpp"
 #include "Domain/Structure/ElementId.hpp"
 #include "Parallel/DomainDiagnosticInfo.hpp"
 #include "Parallel/GlobalCache.hpp"
@@ -37,6 +38,7 @@ template <typename F, size_t Dim, typename Metavariables>
 void create_elements_using_distribution(
     const F& func, const std::optional<domain::ElementWeight>& element_weight,
     const std::vector<Block<Dim>>& blocks,
+    const ::ExcisionSphere<Dim>& worldtube,
     const std::vector<std::array<size_t, Dim>>& initial_extents,
     const std::vector<std::array<size_t, Dim>>& initial_refinement_levels,
     const Spectral::Basis i1_basis, const Spectral::Quadrature i1_quadrature,
@@ -51,10 +53,18 @@ void create_elements_using_distribution(
   // robin.
   domain::BlockZCurveProcDistribution<Dim> element_distribution{};
   if (element_weight.has_value()) {
-    const std::unordered_map<ElementId<Dim>, double> element_costs =
+    std::unordered_map<ElementId<Dim>, double> element_costs =
         domain::get_element_costs(blocks, initial_refinement_levels,
                                   initial_extents, element_weight.value(),
                                   i1_basis, i1_quadrature);
+    for (const auto& [id, weight] : element_costs) {
+      if (worldtube.abutting_direction(id).has_value()) {
+        element_costs[id] *= 8.;
+      }
+      if (blocks[id.block_id()].has_distorted_frame()) {
+        element_costs[id] *= 1.2;
+      }
+    }
     element_distribution = domain::BlockZCurveProcDistribution<Dim>{
         element_costs,   num_of_procs_to_use, blocks, initial_refinement_levels,
         initial_extents, procs_to_ignore};
